const fs = require('fs');
const path = require('path');
const chokidar = require('chokidar');

/*
  COMPONENT FACTORY GENERATION
  Generates the /src/temp/componentFactory.js file which maps React components
  to JSS components.

  The component factory is a mapping between a string name and a React component instance.
  When the Sitecore Layout service returns a layout definition, it returns named components.
  This mapping is used to construct the component hierarchy for the layout.

  The default convention uses the parent folder name as the component name,
  but it is customizable in generateComponentFactory().

  NOTE: this script can run in two modes. The default mode, the component factory file is written once.
  But if `--watch` is a process argument, the component factory source folder will be watched,
  and the componentFactory.js rewritten on added or deleted files.
  This is used during `jss start` to pick up new or removed components at runtime.
*/

/* eslint-disable no-console */

const componentFactoryPath = path.resolve('src/temp/componentFactory.js');
const componentRootPath = 'src/components';

const isWatch = process.argv.some((arg) => arg === '--watch');

if (isWatch) {
  watchComponentFactory();
} else {
  writeComponentFactory();
}

function watchComponentFactory() {
  console.log(`Watching for changes to component factory sources in ${componentRootPath}...`);

  chokidar
    .watch(componentRootPath, { ignoreInitial: true, awaitWriteFinish: true })
    .on('add', writeComponentFactory)
    .on('unlink', writeComponentFactory);
}

function writeComponentFactory() {
  const componentFactory = generateComponentFactory();

  console.log(`Writing component factory to ${componentFactoryPath}`);

  fs.writeFileSync(componentFactoryPath, componentFactory, { encoding: 'utf8' });
}

function registerExternalComponents(imports, registrations) {
  const definitions = [
    {
      nameInstanceMaps: [
        {
          importVarName: 'EsiChoose',
          componentName: 'EsiChoose',
        },
        {
          importVarName: 'EsiInclude',
          componentName: 'EsiInclude',
        },
        {
          importVarName: 'EsiOtherwise',
          componentName: 'EsiOtherwise',
        },
        {
          importVarName: 'EsiWhen',
          componentName: 'EsiWhen',
        },
        {
          importVarName: 'EsiNullComponent',
          componentName: 'EsiNullComponent',
        },
        {
          importVarName: 'EsiForEach',
          componentName: 'EsiForEach',
        },
        {
          importVarName: 'EsiAssign',
          componentName: 'EsiAssign',
        },
        {
          importVarName: 'EsiText',
          componentName: 'EsiText',
        },
        {
          importVarName: 'EsiScript',
          componentName: 'EsiScript',
        },
        {
          importVarName: 'EsiNoOutput',
          componentName: 'EsiNoOutput',
        },
        {
          importVarName: 'EsiContextCsr',
          componentName: 'EsiContextCsr',
        },
        {
          importVarName: 'EsiContextSsr',
          componentName: 'EsiContextSsr',
        },
      ],
      importPath: '@uniformdev/esi-jss-react',
    },
  ];

  definitions.forEach((definition) => {
    const importVarNames = definition.nameInstanceMaps.map((map) => map.importVarName).join(',');
    imports.push(`import { ${importVarNames} } from '${definition.importPath}';`);

    definition.nameInstanceMaps.forEach((map) => {
      console.debug(`Registering JSS component ${map.componentName}`);
      registrations.push(`components.set('${map.componentName}', ${map.importVarName});`);
    });
  });
}

function generateComponentFactory() {
  // by convention, we expect to find React components
  // * under /src/components/ComponentName
  // * with an index.js under the folder to define the component
  // If you'd like to use your own convention, encode it below.
  // NOTE: generating the component factory is also totally optional,
  // and it can be maintained manually if preferred.

  const imports = [];
  const registrations = [];

  fs.readdirSync(componentRootPath).forEach((componentFolder) => {
    const componentFolderFullPath = path.join(componentRootPath, componentFolder);

    if (
      fs.existsSync(path.join(componentFolderFullPath, 'index.js')) ||
      fs.existsSync(path.join(componentFolderFullPath, 'index.jsx'))
    ) {
      const importVarName = componentFolder.replace(/[^\w]+/g, '');

      console.debug(`Registering JSS component ${componentFolder}`);
      imports.push(`import ${importVarName} from '../components/${componentFolder}';`);
      registrations.push(`components.set('${componentFolder}', ${importVarName});`);
    }
  });

  registerExternalComponents(imports, registrations);

  return `/* eslint-disable */
// Do not edit this file, it is auto-generated at build time!
// See scripts/generate-component-factory.js to modify the generation of this file.
${imports.join('\n')}

import { withPersonalization, getPersonalizer } from '@uniformdev/personalize-react';
import { getPersonalizedProps } from '@uniformdev/esi-jss-react';

const components = new Map();
${registrations.join('\n')}

const nonPersonalizableComponents = [
  "EsiAssign", 
  "EsiChoose", 
  "EsiForEach", 
  "EsiInclude", 
  "EsiNoOutput",
  "EsiNullComponent", 
  "EsiOtherwise", 
  "EsiScript", 
  "EsiText", 
  "EsiWhen", 
  "EsiContextCsr",
  "EsiContextSsr"
];

function doNotPersonalize(componentName) {
  return nonPersonalizableComponents.indexOf(componentName) != -1;
}

//
//The allowed array is a collection of component names 
//that support personalization. If the array is empty,
//all components are supported. If the array has at 
//least one item, only the components whose names
//match a value in the array are supported.
const allowed = [];
const Personalizer = getPersonalizer({ components, getPersonalizedProps, allowed });

export default function componentFactory(componentName) {
  const component = components.get(componentName);
  if(!component){
    console.warn("Component " + componentName + " cannot be found in componentFactory and skipped from render.");
    return null;
  }
  if (doNotPersonalize(componentName)) {
    return component;
  }
  return Personalizer;
}
`;
}